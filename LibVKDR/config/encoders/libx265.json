{
  "name": "libx265",
  "authors": [
    "Daniel Stankewitz"
  ],
  "defaultPixelFormat": "yuv420p",
  "groups": [
    {
      "name": "VKDRx265ModeDecisionAnalysisGroup",
      "label": "Mode decision / Analysis",
      "parent": "VKDRAdvVideoCodecTabGroup"
    },
    {
      "name": "VKDRx265TemporalMotionSearchOptionsGroup",
      "label": "Temporal / motion search options",
      "parent": "VKDRAdvVideoCodecTabGroup"
    }
  ],
  "multipass": {
    "name": "x265Passes"
  },
  "parameterGroups": {
    "x265-params": {
      "delimiter": "=",
      "separator": ":",
      "noValueReplacement": "1",
      "parameters": [
        "interlace",
        "lossless",
        "rd",
        "ctu",
        "min-cu-size",
        "limit-refs",
        "limit-modes",
        "no-limit-modes",
        "rect",
        "no-rect",
        "amp",
        "no-amp",
        "early-skip",
        "no-early-skip",
        "rskip",
        "no-rskip",
        "fast-intra",
        "no-fast-intra",
        "b-intra",
        "no-b-intra",
        "cu-lossless",
        "no-cu-lossless",
        "tskip-fast",
        "no-tskip-fast",
        "rd-refine",
        "no-rd-refine",
        "refine-intra",
        "refine-inter",
        "dynamic-refine",
        "no-dynamic-refine",
        "refine-mv",
        "tu-intra-depth",
        "tu-inter-depth",
        "limit-tu",
        "nr-intra",
        "nr-inter",
        "tskip",
        "no-tskip",
        "rdpenalty",
        "max-tu-size",
        "dynamic-rd",
        "ssim-rd",
        "no-ssim-rd",
        "max-merge",
        "me",
        "subme",
        "merange",
        "temporal-mvp",
        "no-temporal-mvp",
        "weightp",
        "no-weightp",
        "weightb",
        "no-weightb",
        "analyze-src-pics",
        "no-analyze-src-pics"
      ]
    }
  },
  "interlaced": {
    "bottomFrameFirst": {
      "interlace": "bff",
      "top": "0"
    },
    "topFrameFirst": {
      "interlace": "tff",
      "top": "1"
    },
    "progressive": {}
  },
  "params": [
    {
      "name": "x265PixelFormat",
      "label": "Color Format",
      "description": "Color encoding system.",
      "group": "ADBEVideoCodecGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "YUV 4:2:0",
          "pixelFormat": "yuv420p",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "YUV 4:2:2",
          "pixelFormat": "yuv422p",
          "parameters": {}
        },
        {
          "id": 2,
          "name": "YUV 4:4:4",
          "pixelFormat": "yuv444p",
          "parameters": {}
        },
        {
          "id": 3,
          "name": "YUV 4:2:0 (10 bit)",
          "pixelFormat": "yuv420p10le",
          "parameters": {}
        },
        {
          "id": 4,
          "name": "YUV 4:2:2 (10 bit)",
          "pixelFormat": "yuv422p10le",
          "parameters": {}
        },
        {
          "id": 5,
          "name": "YUV 4:4:4 (10 bit)",
          "pixelFormat": "yuv444p10le",
          "parameters": {}
        },
        {
          "id": 6,
          "name": "YUV 4:2:0 (12 bit)",
          "pixelFormat": "yuv420p12le",
          "parameters": {}
        },
        {
          "id": 7,
          "name": "YUV 4:2:2 (12 bit)",
          "pixelFormat": "yuv422p12le",
          "parameters": {}
        },
        {
          "id": 8,
          "name": "YUV 4:4:4 (12 bit)",
          "pixelFormat": "yuv444p12le",
          "parameters": {}
        }
      ]
    },
    {
      "name": "x265Preset",
      "label": "Preset",
      "description": "Processing time of each frame. Slower values increase the overall video quality but take more time to process.",
      "group": "ADBEVideoCodecGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 5,
      "values": [
        {
          "id": 0,
          "name": "Ultra fast",
          "parameters": {
            "preset": "ultrafast"
          }
        },
        {
          "id": 1,
          "name": "Super fast",
          "parameters": {
            "preset": "superfast"
          }
        },
        {
          "id": 2,
          "name": "Very fast",
          "parameters": {
            "preset": "veryfast"
          }
        },
        {
          "id": 3,
          "name": "Faster",
          "parameters": {
            "preset": "faster"
          }
        },
        {
          "id": 4,
          "name": "Fast",
          "parameters": {
            "preset": "fast"
          }
        },
        {
          "id": 5,
          "name": "Medium",
          "parameters": {
            "preset": "medium"
          }
        },
        {
          "id": 6,
          "name": "Slow",
          "parameters": {
            "preset": "slow"
          }
        },
        {
          "id": 7,
          "name": "Slower",
          "parameters": {
            "preset": "slower"
          }
        },
        {
          "id": 8,
          "name": "Very slow",
          "parameters": {
            "preset": "veryslow"
          }
        },
        {
          "id": 9,
          "name": "Placebo",
          "parameters": {
            "preset": "placebo"
          }
        }
      ]
    },
    {
      "name": "x265Strategy",
      "label": "Strategy",
      "group": "ADBEVideoCodecGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 1,
      "values": [
        {
          "id": 0,
          "name": "Average Bitrate (ARB)",
          "subvalues": [
            {
              "name": "x265StrategyARB",
              "label": "Average Bitrate [kbit]",
              "description": "The average data rate allowed by the encoder.",
              "type": "int",
              "flags": [
                "slider"
              ],
              "useDefaultValue": true,
              "defaultValue": 15000,
              "minValue": 100,
              "maxValue": 100000,
              "parameters": {
                "b": "%d000"
              }
            }
          ]
        },
        {
          "id": 1,
          "name": "Constant Rate Factor (CRF)",
          "subvalues": [
            {
              "name": "x265StrategyCRF",
              "label": "Constant Rate Factor",
              "description": "Lower values mean better quality but increase the processing time.",
              "type": "int",
              "flags": [
                "slider"
              ],
              "useDefaultValue": true,
              "defaultValue": 28,
              "minValue": 1,
              "maxValue": 51,
              "parameters": {
                "crf": "%d"
              }
            }
          ]
        },
        {
          "id": 2,
          "name": "Constant Quantizer (CQP)",
          "subvalues": [
            {
              "name": "x265StrategyQP",
              "label": "Constant Quantizer",
              "description": "Quality level of the video. Lower values mean better quality but increase file size and processing time.",
              "type": "int",
              "flags": [
                "slider"
              ],
              "useDefaultValue": true,
              "defaultValue": 23,
              "minValue": 1,
              "maxValue": 51,
              "parameters": {
                "qp": "%d"
              }
            }
          ]
        },
        {
          "id": 3,
          "name": "Lossless",
          "parameters": {
            "lossless": ""
          }
        }
      ]
    },
    {
      "name": "x265Rd",
      "label": "RD",
      "description": "Level of RDO in mode decision. The higher the value, the more exhaustive the analysis and the more rate distortion optimization is used. The lower the value the faster the encode, the higher the value the smaller the bitstream (in general).",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 3,
      "values": [
        {
          "id": 1,
          "name": "recon generated (better intra), RDO merge/skip selection",
          "parameters": {
            "rd": "1"
          }
        },
        {
          "id": 2,
          "name": "RDO splits and merge/skip selection",
          "parameters": {
            "rd": "2"
          }
        },
        {
          "id": 3,
          "name": "RDO mode and split decisions, chroma residual used for sa8d",
          "parameters": {
            "rd": "3"
          }
        },
        {
          "id": 5,
          "name": "Adds RDO prediction decisions",
          "parameters": {
            "rd": "5"
          }
        }
      ]
    },
    {
      "name": "x265Ctu",
      "label": "Coding tree unit",
      "description": "Maximum CU size (width and height). The larger the maximum CU size, the more efficiently x265 can encode flat areas of the picture, giving large reductions in bitrate. However this comes at a loss of parallelism with fewer rows of CUs that can be encoded in parallel, and less frame parallelism as well. Because of this the faster presets use a CU size of 32.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "64",
          "parameters": {
            "ctu": "64"
          }
        },
        {
          "id": 2,
          "name": "32",
          "parameters": {
            "ctu": "32"
          }
        },
        {
          "id": 3,
          "name": "16",
          "parameters": {
            "ctu": "16"
          }
        }
      ]
    },
    {
      "name": "x265MinCtuSize",
      "label": "Coding tree unit (Min.)",
      "description": "Minimum CU size (width and height). By using 16 or 32 the encoder will not analyze the cost of CUs below that minimum threshold, saving considerable amounts of compute with a predictable increase in bitrate. This setting has a large effect on performance on the faster presets.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 2,
      "values": [
        {
          "id": 0,
          "name": "32",
          "parameters": {
            "min-cu-size": "32"
          }
        },
        {
          "id": 1,
          "name": "16",
          "parameters": {
            "min-cu-size": "16"
          }
        },
        {
          "id": 2,
          "name": "8",
          "parameters": {
            "min-cu-size": "8"
          }
        }
      ]
    },
    {
      "name": "x265LimitRefs",
      "label": "Limit References",
      "description": "When set to X265_REF_LIMIT_DEPTH (1) x265 will limit the references analyzed at the current depth based on the references used to code the 4 sub-blocks at the next depth. For example, a 16x16 CU will only use the references used to code its four 8x8 CUs.\n\nWhen set to X265_REF_LIMIT_CU (2), the rectangular and asymmetrical partitions will only use references selected by the 2Nx2N motion search (including at the lowest depth which is otherwise unaffected by the depth limit).\n\nWhen set to 3 (X265_REF_LIMIT_DEPTH && X265_REF_LIMIT_CU), the 2Nx2N motion search at each depth will only use references from the split CUs and the rect/amp motion searches at that depth will only use the reference(s) selected by 2Nx2N.\n\nFor all non-zero values of limit-refs, the current depth will evaluate intra mode (in inter slices), only if intra mode was chosen as the best mode for atleast one of the 4 sub-blocks.\n\n.You can often increase the number of references you are using (within your decoder level limits) if you enable one or both of these flags.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 3,
      "values": [
        {
          "id": 0,
          "name": "(Disabled)",
          "parameters": {
            "limit-refs": "0"
          }
        },
        {
          "id": 1,
          "name": "Limit Depth",
          "parameters": {
            "limit-refs": "1"
          }
        },
        {
          "id": 2,
          "name": "Limit CU",
          "parameters": {
            "limit-refs": "2"
          }
        },
        {
          "id": 3,
          "name": "Limit Depth & Limit CU",
          "parameters": {
            "limit-refs": "3"
          }
        }
      ]
    },
    {
      "name": "x265LimitModes",
      "label": "Limit Modes",
      "description": "When enabled, limit-modes will limit modes analyzed for each CU using cost metrics from the 4 sub-CUs. When multiple inter modes like --rect and/or --amp are enabled, this feature will use motion cost heuristics from the 4 sub-CUs to bypass modes that are unlikely to be the best choice. This can significantly improve performance when rect and/or --amp are enabled at minimal compression efficiency loss.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "limit-modes": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-limit-modes": ""
          }
        }
      ]
    },
    {
      "name": "x265Rect",
      "label": "Rect",
      "description": "Enable analysis of rectangular motion partitions Nx2N and 2NxN (50/50 splits, two directions).",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "rect": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-rect": ""
          }
        }
      ]
    },
    {
      "name": "x265Amp",
      "label": "Amp",
      "description": "Enable analysis of asymmetric motion partitions (75/25 splits, four directions). At RD levels 0 through 4, AMP partitions are only considered at CU sizes 32x32 and below. At RD levels 5 and 6, it will only consider AMP partitions as merge candidates (no motion search) at 64x64, and as merge or inter candidates below 64x64.\n\nThe AMP partitions which are searched are derived from the current best inter partition. If Nx2N (vertical rectangular) is the best current prediction, then left and right asymmetrical splits will be evaluated. If 2NxN (horizontal rectangular) is the best current prediction, then top and bottom asymmetrical splits will be evaluated, If 2Nx2N is the best prediction, and the block is not a merge/skip, then all four AMP partitions are evaluated.\n\nThis setting has no effect if rectangular partitions are disabled.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "amp": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-amp": ""
          }
        }
      ]
    },
    {
      "name": "x265EarlySkip",
      "label": "Early Skip",
      "description": "Measure 2Nx2N merge candidates first; if no residual is found, additional modes at that depth are not analysed.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "early-skip": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-early-skip": ""
          }
        }
      ]
    },
    {
      "name": "x265RSkip",
      "label": "R Skip",
      "description": "This option determines early exit from CU depth recursion. When a skip CU is found, additional heuristics (depending on rd-level) are used to decide whether to terminate recursion. In rdlevels 5 and 6, comparison with inter2Nx2N is used, while at rdlevels 4 and neighbour costs are used to skip recursion. Provides minimal quality degradation at good performance gains when enabled.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "rskip": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-rskip": ""
          }
        }
      ]
    },
    {
      "name": "x265FastIntra",
      "label": "Fast Intra",
      "description": "Perform an initial scan of every fifth intra angular mode, then check modes +/- 2 distance from the best mode, then +/- 1 distance from the best mode, effectively performing a gradient descent. When enabled 10 modes in total are checked. When disabled all 33 angular modes are checked. Only applicable for --rd levels 4 and below (medium preset and faster).",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "fast-intra": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-fast-intra": ""
          }
        }
      ]
    },
    {
      "name": "x265BIntra",
      "label": "B Intra",
      "description": "Enables the evaluation of intra modes in B slices.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "b-intra": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-b-intra": ""
          }
        }
      ]
    },
    {
      "name": "x265CuLossless",
      "label": "CU Lossless",
      "description": "For each CU, evaluate lossless (transform and quant bypass) encode of the best non-lossless mode option as a potential rate distortion optimization. If the global option --lossless has been specified, all CUs will be encoded as lossless unconditionally regardless of whether this option was enabled.\n\nOnly effective at RD levels 3 and above, which perform RDO mode decisions.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "cu-lossless": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-cu-lossless": ""
          }
        }
      ]
    },
    {
      "name": "x265TSkipFast",
      "label": "Transform Skrip Fast",
      "description": "Only evaluate transform skip for NxN intra predictions (4x4 blocks). Only applicable if transform skip is enabled. For chroma, only evaluate if luma used tskip. Inter block tskip analysis is unmodified.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "tskip-fast": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-tskip-fast": ""
          }
        }
      ]
    },
    {
      "name": "x265RDDefine",
      "label": "RD Define",
      "description": "For each analysed CU, calculate R-D cost on the best partition mode for a range of QP values, to find the optimal rounding effect.\n\nOnly effective at RD levels 5 and 6.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "rd-refine": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-rd-refine": ""
          }
        }
      ]
    },
    {
      "name": "x265RefineIntra",
      "label": "Refine Intra",
      "description": "Enables refinement of intra blocks in current encode.\n\nLevel 0 - Forces both mode and depth from the save encode.\n\nLevel 1 - Evaluates all intra modes at current depth(n) and at depth (n+1) when current block size is one greater than the min-cu-size. Forces modes for larger blocks.\n\nLevel 2 - In addition to the functionality of level 1, at all depths, force (a) only depth when angular mode is chosen by the save encode. (b) depth and mode when other intra modes are chosen by the save encode.\n\nLevel 3 - Perform analysis of intra modes for depth reused from first encode.\n\nLevel 4 - Does not reuse any analysis information - redo analysis for the intra block.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "Level 0",
          "parameters": {
            "refine-intra": "0"
          }
        },
        {
          "id": 1,
          "name": "Level 1",
          "parameters": {
            "refine-intra": "1"
          }
        },
        {
          "id": 2,
          "name": "Level 2",
          "parameters": {
            "refine-intra": "2"
          }
        },
        {
          "id": 3,
          "name": "Level 3",
          "parameters": {
            "refine-intra": "3"
          }
        },
        {
          "id": 4,
          "name": "Level 4",
          "parameters": {
            "refine-intra": "4"
          }
        }
      ]
    },
    {
      "name": "x265RefineInter",
      "label": "Refine Inter",
      "description": "Enables refinement of inter blocks in current encode.\n\nLevel 0 - Forces both mode and depth from the save encode.\n\nLevel 1 - Evaluates all inter modes at current depth(n) and at depth (n+1) when current block size is one greater than the min-cu-size. Forces modes for larger blocks.\n\nLevel 2 - In addition to the functionality of level 1, restricts the modes evaluated when specific modes are decided as the best mode by the save encode.\n\n2nx2n in save encode - disable re-evaluation of rect and amp.\n\nskip in save encode - re-evaluates only skip, merge and 2nx2n modes.\n\nLevel 3 - Perform analysis of inter modes while reusing depths from the save encode.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "Level 0",
          "parameters": {
            "refine-inter": "0"
          }
        },
        {
          "id": 1,
          "name": "Level 1",
          "parameters": {
            "refine-inter": "1"
          }
        },
        {
          "id": 2,
          "name": "Level 2",
          "parameters": {
            "refine-inter": "2"
          }
        },
        {
          "id": 3,
          "name": "Level 3",
          "parameters": {
            "refine-inter": "3"
          }
        }
      ]
    },
    {
      "name": "x265DynamicRefine",
      "label": "Dynamic Refine",
      "description": "Dynamically switches --refine-inter levels 0-3 based on the content and the encoder settings. It is recommended to use --refine-intra 4 with dynamic refinement.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "dynamic-refine": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-dynamic-refine": ""
          }
        }
      ]
    },
    {
      "name": "x265RefineMV",
      "label": "Refine Motion Vector",
      "description": "Enables refinement of motion vector for scaled video. Evaluates the best motion vector by searching the surrounding eight integer and subpel pixel positions.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "bool",
      "flags": [],
      "defaultValue": 0,
      "parameters": {
        "refine-mv": ""
      }
    },
    {
      "name": "x265TUIntraDepth",
      "label": "TU Intra Depth",
      "description": "The transform unit (residual) quad-tree begins with the same depth as the coding unit quad-tree, but the encoder may decide to further split the transform unit tree if it improves compression efficiency. This setting limits the number of extra recursion depth which can be attempted for intra coded units. Default: 1, which means the residual quad-tree is always at the same depth as the coded unit quad-tree\n\nNote that when the CU intra prediction is NxN (only possible with 8x8 CUs), a TU split is implied, and thus the residual quad-tree begins at 4x4 and cannot split any futhrer.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [ "slider" ],
      "defaultValue": 1,
      "minValue": 1,
      "maxValue": 4,
      "parameters": {
        "tu-intra-depth": "%d"
      }
    },
    {
      "name": "x265TUInterDepth",
      "label": "TU Inter Depth",
      "description": "The transform unit (residual) quad-tree begins with the same depth as the coding unit quad-tree, but the encoder may decide to further split the transform unit tree if it improves compression efficiency. This setting limits the number of extra recursion depth which can be attempted for inter coded units. Default: 1. which means the residual quad-tree is always at the same depth as the coded unit quad-tree unless the CU was coded with rectangular or AMP partitions, in which case a TU split is implied and thus the residual quad-tree begins one layer below the CU quad-tree.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [ "slider" ],
      "defaultValue": 1,
      "minValue": 1,
      "maxValue": 4,
      "parameters": {
        "tu-inter-depth": "%d"
      }
    },
    {
      "name": "x265LimitTU",
      "label": "Limit TU",
      "description": "Enables early exit from TU depth recursion, for inter coded blocks.\n\nLevel 1 - decides to recurse to next higher depth based on cost comparison of full size TU and split TU.\n\nLevel 2 - based on first split subTUs depth, limits recursion of other split subTUs.\n\nLevel 3 - based on the average depth of the co-located and the neighbor CUs TU depth, limits recursion of the current CU.\n\nLevel 4 - uses the depth of the neighbouring co-located CUs TU depth to limit the 1st subTU depth. The 1st subTU depth is taken as the limiting depth for the other subTUs.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "Level 0",
          "parameters": {
            "limit-tu": "0"
          }
        },
        {
          "id": 1,
          "name": "Level 1",
          "parameters": {
            "limit-tu": "1"
          }
        },
        {
          "id": 2,
          "name": "Level 2",
          "parameters": {
            "limit-tu": "2"
          }
        },
        {
          "id": 3,
          "name": "Level 3",
          "parameters": {
            "limit-tu": "3"
          }
        },
        {
          "id": 4,
          "name": "Level 4",
          "parameters": {
            "limit-tu": "4"
          }
        }
      ]
    },
    {
      "name": "x265NrIntra",
      "label": "Noise Reduction (Intra)",
      "description": "Noise reduction - an adaptive deadzone applied after DCT (subtracting from DCT coefficients), before quantization. It does no pixel-level filtering, doesnt cross DCT block boundaries, has no overlap, The higher the strength value parameter, the more aggressively it will reduce noise.\n\nEnabling noise reduction will make outputs diverge between different numbers of frame threads. Outputs will be deterministic but the outputs of -F2 will no longer match the outputs of -F3, etc.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [ "slider" ],
      "defaultValue": 0,
      "minValue": 0,
      "maxValue": 2000,
      "parameters": {
        "nr-intra": "%d"
      }
    },
    {
      "name": "x265NrInter",
      "label": "Noise Reduction (Inter)",
      "description": "Noise reduction - an adaptive deadzone applied after DCT (subtracting from DCT coefficients), before quantization. It does no pixel-level filtering, doesnt cross DCT block boundaries, has no overlap, The higher the strength value parameter, the more aggressively it will reduce noise.\n\nEnabling noise reduction will make outputs diverge between different numbers of frame threads. Outputs will be deterministic but the outputs of -F2 will no longer match the outputs of -F3, etc.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [ "slider" ],
      "defaultValue": 0,
      "minValue": 0,
      "maxValue": 2000,
      "parameters": {
        "nr-inter": "%d"
      }
    },
    {
      "name": "x265TSkip",
      "label": "T Skip",
      "description": "Enable evaluation of transform skip (bypass DCT but still use quantization) coding for 4x4 TU coded blocks.\n\nOnly effective at RD levels 3 and above, which perform RDO mode decisions.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "tskip": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-tskip": ""
          }
        }
      ]
    },
    {
      "name": "x265RDPenalty",
      "label": "RD Penalty",
      "description": "When set to 1, transform units of size 32x32 are given a 4x bit cost penalty compared to smaller transform units, in intra coded CUs in P or B slices.\n\nWhen set to 2, transform units of size 32x32 are not even attempted, unless otherwise required by the maximum recursion depth. For this option to be effective with 32x32 intra CUs, --tu-intra-depth must be at least 2. For it to be effective with 64x64 intra CUs, --tu-intra-depth must be at least 3.\n\nNote that in HEVC an intra transform unit (a block of the residual quad-tree) is also a prediction unit, meaning that the intra prediction signal is generated for each TU block, the residual subtracted and then coded. The coding unit simply provides the prediction modes that will be used when predicting all of the transform units within the CU. This means that when you prevent 32x32 intra transform units, you are preventing 32x32 intra predictions.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [ "slider" ],
      "defaultValue": 0,
      "minValue": 0,
      "maxValue": 2,
      "parameters": {
        "rdpenalty": "%d"
      }
    },
    {
      "name": "x265MaxTUSize",
      "label": "Maximum TU size",
      "description": "Maximum TU size (width and height). The residual can be more efficiently compressed by the DCT transform when the max TU size is larger, but at the expense of more computation. Transform unit quad-tree begins at the same depth of the coded tree unit, but if the maximum TU size is smaller than the CU size then transform QT begins at the depth of the max-tu-size.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "32",
          "parameters": {
            "max-tu-size": "32"
          }
        },
        {
          "id": 1,
          "name": "16",
          "parameters": {
            "max-tu-size": "16"
          }
        },
        {
          "id": 2,
          "name": "8",
          "parameters": {
            "max-tu-size": "8"
          }
        },
        {
          "id": 3,
          "name": "4",
          "parameters": {
            "max-tu-size": "4"
          }
        }
      ]
    },
    {
      "name": "x265DynamicRD",
      "label": "Dynamic RD",
      "description": "Increases the RD level at points where quality drops due to VBV rate control enforcement. The number of CUs for which the RD is reconfigured is determined based on the strength. Strength 1 gives the best FPS, strength 4 gives the best SSIM. Strength 0 switches this feature off.\n\nEffective for RD levels 4 and below.",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [ "slider" ],
      "defaultValue": 0,
      "minValue": 0,
      "maxValue": 4,
      "parameters": {
        "dynamic-rd": "%d"
      }
    },
    {
      "name": "x265SSimRD",
      "label": "SSIM RD",
      "description": "Enable/Disable SSIM RDO. SSIM is a better perceptual quality assessment method as compared to MSE. SSIM based RDO calculation is based on residual divisive normalization scheme. This normalization is consistent with the luminance and contrast masking effect of Human Visual System. It is used for mode selection during analysis of CTUs and can achieve significant gain in terms of objective quality metrics SSIM and PSNR. It only has effect on presets which use RDO-based mode decisions (--rd 3 and above).",
      "group": "VKDRx265ModeDecisionAnalysisGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "ssim-rd": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-ssim-rd": ""
          }
        }
      ]
    },
    {
      "name": "x265MaxMerge",
      "label": "Max. Merge",
      "description": "Maximum number of neighbor (spatial and temporal) candidate blocks that the encoder may consider for merging motion predictions. If a merge candidate results in no residual, it is immediately selected as a 'skip'. Otherwise the merge candidates are tested as part of motion estimation when searching for the least cost inter option. The max candidate number is encoded in the SPS and determines the bit cost of signaling merge CUs.",
      "group": "VKDRx265TemporalMotionSearchOptionsGroup",
      "type": "int",
      "flags": [ "slider" ],
      "defaultValue": 2,
      "minValue": 1,
      "maxValue": 5,
      "parameters": {
        "max-merge": "%d"
      }
    },
    {
      "name": "x265ME",
      "label": "Motion search method",
      "description": "Generally, the higher the number the harder the ME method will try to find an optimal match. Diamond search is the simplest. Hexagon search is a little better. Uneven Multi-Hexegon is an adaption of the search method used by x264 for slower presets. Star is a three step search adapted from the HM encoder: a star-pattern search followed by an optional radix scan followed by an optional star-search refinement. Full is an exhaustive search; an order of magnitude slower than all other searches but not much better than umh or star. SEA is similar to FULL search; a three step motion search adopted from x264: DC calculation followed by ADS calculation followed by SAD of the passed motion vector candidates, hence faster than Full search.",
      "group": "VKDRx265TemporalMotionSearchOptionsGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 1,
      "values": [
        {
          "id": 0,
          "name": "Diamond",
          "parameters": {
            "me": "dia"
          }
        },
        {
          "id": 1,
          "name": "Hexagon",
          "parameters": {
            "me": "hex"
          }
        },
        {
          "id": 2,
          "name": "Uneven Multi-Hexegon",
          "parameters": {
            "me": "umh"
          }
        },
        {
          "id": 3,
          "name": "Star",
          "parameters": {
            "me": "star"
          }
        },
        {
          "id": 4,
          "name": "SEA",
          "parameters": {
            "me": "sea"
          }
        },
        {
          "id": 5,
          "name": "Full",
          "parameters": {
            "me": "full"
          }
        }
      ]
    },
    {
      "name": "x265SubMe",
      "label": "Subpel refinement",
      "description": "Amount of subpel refinement to perform. The higher the number the more subpel iterations and steps are performed. At -subme values larger than 2, chroma residual cost is included in all subpel refinement steps and chroma residual is included in all motion estimation decisions (selecting the best reference picture in each list, and chosing between merge, uni-directional motion and bi-directional motion). The 'slow' preset is the first preset to enable the use of chroma residual.",
      "group": "VKDRx265TemporalMotionSearchOptionsGroup",
      "type": "int",
      "flags": [ "slider" ],
      "defaultValue": 2,
      "minValue": 0,
      "maxValue": 7,
      "parameters": {
        "subme": "%d"
      }
    },
    {
      "name": "x265MeRange",
      "label": "Motion search range",
      "description": "The default is derived from the default CTU size (64) minus the luma interpolation half-length (4) minus maximum subpel distance (2) minus one extra pixel just in case the hex search method is used. If the search range were any larger than this, another CTU row of latency would be required for reference frames.",
      "group": "VKDRx265TemporalMotionSearchOptionsGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 57,
      "minValue": 0,
      "maxValue": 32768,
      "parameters": {
        "merange ": "%d"
      }
    },
    {
      "name": "x265TemporalMvp",
      "label": "Temporal MVP",
      "description": "Enable temporal motion vector predictors in P and B slices. This enables the use of the motion vector from the collocated block in the previous frame to be used as a predictor.",
      "group": "VKDRx265TemporalMotionSearchOptionsGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "temporal-mvp": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-temporal-mvp": ""
          }
        }
      ]
    },
    {
      "name": "x265WeightP",
      "label": "Weighted Prediction",
      "description": "Enable weighted prediction in P slices. This enables weighting analysis in the lookahead, which influences slice decisions, and enables weighting analysis in the main encoder which allows P reference samples to have a weight function applied to them prior to using them for motion compensation. In video which has lighting changes, it can give a large improvement in compression efficiency.",
      "group": "VKDRx265TemporalMotionSearchOptionsGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "weightp": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-weightp": ""
          }
        }
      ]
    },
    {
      "name": "x265WeightB",
      "label": "Weighted Prediction (B slices)",
      "description": "Enable weighted prediction in B slices.",
      "group": "VKDRx265TemporalMotionSearchOptionsGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "weightb": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-weightb": ""
          }
        }
      ]
    },
    {
      "name": "x265AnayzeSourcePics",
      "label": "Analyze source pics",
      "description": "Enable motion estimation with source frame pixels, in this mode, motion estimation can be computed independently.",
      "group": "VKDRx265TemporalMotionSearchOptionsGroup",
      "type": "int",
      "flags": [],
      "defaultValue": 0,
      "values": [
        {
          "id": 0,
          "name": "(Default)",
          "parameters": {}
        },
        {
          "id": 1,
          "name": "Enabled",
          "parameters": {
            "analyze-src-pics": ""
          }
        },
        {
          "id": 2,
          "name": "Disabled",
          "parameters": {
            "no-analyze-src-pics": ""
          }
        }
      ]
    }
  ]
}